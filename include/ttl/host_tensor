// # -*- mode: c++ -*-
#pragma once
#include <ttl/bits/std_tensor.hpp>
#include <ttl/shape>

namespace ttl
{
namespace internal
{
using internal::rank_t;

template <typename R, rank_t r, typename D = internal::host_memory>
using tensor =
    internal::basic_tensor<R, internal::basic_shape<r>, D, internal::owner>;

template <typename R, rank_t r, typename D = internal::host_memory>
using tensor_ref =
    internal::basic_tensor<R, internal::basic_shape<r>, D, internal::readwrite>;

template <typename R, rank_t r, typename D = internal::host_memory>
using tensor_view =
    internal::basic_tensor<R, internal::basic_shape<r>, D, internal::readonly>;

template <typename R, rank_t r>
using host_tensor = tensor<R, r, internal::host_memory>;

template <typename R, rank_t r>
using host_tensor_ref = tensor_ref<R, r, internal::host_memory>;

template <typename R, rank_t r>
using host_tensor_view = tensor_view<R, r, internal::host_memory>;
}  // namespace internal
}  // namespace ttl

namespace ttl
{
using internal::host_tensor;
using internal::host_tensor_ref;
using internal::host_tensor_view;
}  // namespace ttl

namespace ttl
{
// Don't be confused with std::vector
template <typename R> using vector = host_tensor<R, 1>;
template <typename R> using vector_ref = host_tensor_ref<R, 1>;
template <typename R> using vector_view = host_tensor_view<R, 1>;

template <typename R> using matrix = host_tensor<R, 2>;
template <typename R> using matrix_ref = host_tensor_ref<R, 2>;
template <typename R> using matrix_view = host_tensor_view<R, 2>;
}  // namespace ttl
